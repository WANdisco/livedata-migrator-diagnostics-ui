<!DOCTYPE html>
<html>
<head>
<title>LDM Diagnostics</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/diagnostics.css">
<script src="/js/chart.min.js"></script>
<script src="/js/sorttable.js"></script>
<script src="/js/common.js"></script>
</head>

<body>
<!-- Navbar -->
<div class="topnav">
    <a id="index-link" href="/">Summary</a>
    <a href="/throughput.html">Throughput</a>
    <a id="system-link" href="/system.html">System</a>
    <a id="network-link" href="/network.html">Network</a>
    <a id="migrations-link" href="/migrations.html">Migrations</a>
    <a id="filetracker-link" href="/filetrackers.html">Transfers</a>
</div>

<div class="content">
    <div class="tooltip">
       <span class="tooltiptext">Click point in graph to display point in time file transfers.</span>
       <div>
          <h1>File Transfers Count</h1>
       </div>
    </div>

      <div>
         <canvas id="FileTrackerChart"></canvas>
      </div>
       <div style="text-align:center">
          <div class="tooltip">
            <span class="tooltiptext">Move slider to report point in time Diagnostics.</span>
            <h2 style="text-align:center"><span id="current-timestamp"></span></h2>
         </div>
       </div>
       <div>
    <div>
       <table>
         <tr>
            <td style="text-align:right"><span id="startDate"></span></td>
            <td style="width:50%"><input type="range" min=0 max="100" value="100" class="slider" id="myRange"></td>
            <td style="text-align:left"><span id="endDate"></span></td>
            <td style="text-align:right">Scale</td>
            <td style="text-align:right">-</td>
            <td style="width:10%"><input type="range" min=60 max="1440" value="240" class="slider" id="zoomSlider"></td>
            <td style="text-align:left">+</td>
         </tr>
       </table>
    </div>

    <div class="tooltip">
      <span class="tooltiptext">Select row in table to display individual file transfer graph. Transfers that have completed cannot be graphed.</span>
      <div>
         <h2><span id="transfer-count"></span> Transfers at <span id="time-of-transfers"><span></h2>
      </div>
    </div>

    <div>
       <table id="fileTracker-table"></table>
    </div>
</div>

<div class="footer">
  <p></p>
</div>

<script>


var fileTrackerChart;
var filetrackerCount;
var throughout;
var dates;
var startIndex = 0;
var zoomScale = 240;
function doFileTrackerChart(filetrackers) {
  filetrackerCount = filetrackers.filetrackerCount;
  throughput = filetrackers.bytesPerSecond.map(toMBSecond)  	
  dates = filetrackers.timeStamp.map(toDate);

  let endIndex = startIndex + zoomScale;
  if (endIndex >= dates.length) {
    endIndex = dates.length;
  }

  fileTrackerChart = new Chart("FileTrackerChart", {
    type: "line",
    data: {
      labels: dates.slice(startIndex, endIndex),
      datasets: [{
        label: "Active File Transfers",
        fill: false,
        lineTension: 0.4,
        backgroundColor: transparentize(255, 99, 132, 0.5),
        borderColor: 'rgb(255, 99, 132)',
        data: filetrackerCount.slice(startIndex, endIndex),
        yAxisID: 'y',
      },
      {
        label: "Mbit/s",
        fill: false,
        lineTension: 0.4,
        backgroundColor:  transparentize(54, 162, 235, 0.5),
        borderColor: 'rgb(54, 162, 235)',
        data: throughput.slice(startIndex, endIndex),
        yAxisID: 'y1',
      }]
    },
    options: {
      responsive: true,
      plugins: {
        title: {
          display: true,
          text: "Active File Transfer Count"
        }
      },
      scales: {
        x: {
          display: true,
          title: {
            display: false,
            text: 'Date'
          }
        },
        y: {
          display: true,
          type: 'linear',
          min: 0.0,
          title: {
            display: true,
            text: 'Active File Transfers'
          }
        },
        y1: {
          display: true,
          type: 'linear',
          min: 0.0,
          position: 'right', 
          grid: {
             drawOnChartArea: false, // only want the grid lines for one axis to show up
          },
          title: {
            display: true,
            text: 'Mbit/s'
          }
        }	      
      }
    }
  });
}

document.getElementById("FileTrackerChart").onclick = function(evt) {
  var activePoint = fileTrackerChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);;

  // make sure click was on an actual point
  if (activePoint.length > 0) {
    var clickedElementindex = activePoint[0].index;
    getDiagnostic(timeStamps[startIndex + clickedElementindex]);
    reWriteLinks(timeStamps[startIndex + clickedElementindex]);	  
  }
};


function reWriteLinks(index) {
    document.getElementById('index-link').href = "/?index=" + index;
    document.getElementById('system-link').href = "/system.html?index=" + index;
    document.getElementById('migrations-link').href = "/migrations.html?index=" + index;
    document.getElementById('network-link').href = "/network.html?index=" + index;
}

var timeStamps;
async function getFileTrackers(pageIndex) {
  let url = '/api/filetrackers';
  try {
    let res = await fetch(url);
    let json =  await res.json();
    timeStamps = json.timeStamp;
    if (pageIndex > 0 ) {
       for (let i = 0; i < timeStamps.length; i++) {
         if (timeStamps[i] === pageIndex) {
            startIndex = i;
            break; 
         }
       }	       	      
    }
    doFileTrackerChart(json);
    processSlider(json.timeStamp[0], json.timeStamp[json.timeStamp.length - 1], json.timeStamp.length, startIndex);
    return;
  } catch (error) {
    console.log(error);
  }
}

var diagnostics;
async function getDiagnostic(index) {
  let url = '/api/diagnostic?index=' + index;
  try {
    let res = await fetch(url);
    let json =  await res.json();
    diagnostics = json;
    processDiagnostic(json, index);
    return;
  } catch (error) {
    console.log(error);
  }
}

function processFileTrackerTable(diagnostic, index) {
  document.getElementById("time-of-transfers").innerHTML  = new Date(diagnostic.timeStamp).toISOString().slice(0,-5);
  document.getElementById("transfer-count").innerHTML  = diagnostic.fileTrackers.length;
  document.getElementById("fileTracker-table").innerHTML = "";
  if (diagnostic.fileTrackers.length == 0 ) {
     return;
  }	
  let latencyAvailable = diagnostic.fileTrackers[0].EventLatency ? true : false;
  let timeStamp = diagnostic.timeStamp;
  let text = "<tr><th style=\"cursor: pointer;\">Path</th><th style=\"cursor: pointer;\">Start Time</th><th style=\"cursor: pointer;\">Time</th><th style=\"cursor: pointer;\">File Size</th>"
  if (latencyAvailable) {
     text += "<th style=\"cursor: pointer;\">Latency</th>"
  }
  text +=  "<th style=\"cursor: pointer;\">Transferred</th><th style=\"cursor: pointer;\">Attempt</th><th style=\"cursor: pointer;\">Complete</th><th style=\"cursor: pointer;\">Bytes/s</th></tr>";  
  for (let i in diagnostic.fileTrackers) {
    let fileTracker = diagnostic.fileTrackers[i];
    let time = 0;
    if (fileTracker.IsComplete) {
      time = fileTracker.CompleteTime - fileTracker.StartTime; 
      // Cannot display graph for complete tracker
    } else {
      let endTime = timeStamp > fileTracker.LastUpdate ? timeStamp : fileTracker.LastUpdate;
      time = endTime - fileTracker.StartTime;
    }
    text += "<tr onclick=\"location.href=\'/transfer.html?index=" + index + "&path=" + encodeURIComponent(fileTracker.Path) + "\';\"  style=\"cursor: pointer;\">"
    text += "<td>" + fileTracker.Path + "</td><td>" + new Date(fileTracker.StartTime).toISOString()  + "</td><td>" + time  + "</td><td>" + fileTracker.FileLength  +"</td>"
    if (latencyAvailable) {
       text += "<td>" + fileTracker.EventLatency  + "</td>"
    }
    text += "<td>"+ fileTracker.BytesTransferred  +"</td><td>" + fileTracker.AttemptCount + "</td><td>" + fileTracker.IsComplete  + "</td><td>" + fileTracker.BytesPerSecond + "</td></tr>";
  }
  document.getElementById("fileTracker-table").innerHTML = text;
  var newTableObject = document.getElementById("fileTracker-table");
  sorttable.makeSortable(newTableObject);
}





function processDiagnostic(json, index) {
  for (let j in json.diagnosticSet.diagnostics) {
    let diagnostic = json.diagnosticSet.diagnostics[j];
    if (diagnostic.type === 'FileTrackerDiagnosticDTO') {
      processFileTrackerTable(diagnostic, index);
      break;
    }
  }
}


function processSlider(startDate, endDate, max, index) {
   let newValue = index > 0 ? index : 0;
   document.getElementById("myRange").max = max;
   document.getElementById("myRange").value = newValue;
   document.getElementById("startDate").innerHTML = new Date(startDate).toISOString();
   document.getElementById("endDate").innerHTML = new Date(endDate).toISOString();
   document.getElementById("current-timestamp").innerHTML = new Date(startDate).toISOString();
}

var slider = document.getElementById("myRange");
slider.oninput = function() {
  startIndex = parseInt(this.value);
  redrawChart();
  let offset = startIndex + Math.floor(zoomScale/2); 
  if (offset > timeStamps.length - 1) {
      if (startIndex < timeStamps.length - 1) {
        offset = startIndex;
      } else {
        offset = timeStamps.length - 1;
      }
  }
  document.getElementById("current-timestamp").innerHTML = new Date(timeStamps[offset]).toISOString();
}
slider.onchange = function() {
  startIndex = parseInt(this.value);
  let offset = startIndex + Math.floor(zoomScale/2); 
  if (offset > timeStamps.length - 1) {
      if (startIndex < timeStamps.length - 1) {
        offset = startIndex;
      } else {
        offset = timeStamps.length - 1;
      }
  }
  document.getElementById("current-timestamp").innerHTML = new Date(timeStamps[offset]).toISOString();
  getDiagnostic(timeStamps[offset]);
}

var zoomSlider = document.getElementById("zoomSlider");
zoomSlider.oninput = function() {
  zoomScale = parseInt(this.value);
  redrawChart();
}

function redrawChart() {
  let endIndex = startIndex + zoomScale;
  if (endIndex > dates.length) {
    endIndex = dates.length;
  }
  fileTrackerChart.data.labels = dates.slice(startIndex, endIndex);
  fileTrackerChart.data.datasets[0].data = filetrackerCount.slice(startIndex, endIndex);  
  fileTrackerChart.data.datasets[1].data = throughput.slice(startIndex, endIndex);  
  fileTrackerChart.update();
}

const urlParams = new URLSearchParams(window.location.search);
var pageIndex = urlParams.get('index');
if (!pageIndex) {
   pageIndex = -1;	
} else {
   pageIndex = parseInt(pageIndex);
}
getFileTrackers(pageIndex);
getDiagnostic(pageIndex);

</script>
</body>
</html>
