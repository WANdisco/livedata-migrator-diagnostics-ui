<!DOCTYPE html>
<html>
<head>
<title>LiveData Migrator File Transfer Diagnostic</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="css/nouislider.min.css">
<link rel="stylesheet" href="css/diagnostics.css">
<script src="js/chart.min.js"></script>
<script src="js/sorttable.js"></script>
<script src="js/common.js"></script>
<script src="js/chartjs-plugin-annotation.min.js"></script>
<script src="js/nouislider.min.js"></script>

<style>
.chart-slider-container-grid {
    display: grid;
    grid-template-columns: 200px auto 200px;
    gap: 10px;
}

</style>

</head>

<body>
<!-- Navbar -->
<div class="topnav">
    <a id="index-link", href="index.html">Summary</a>
    <a id="throughput-link", href="throughput.html">Throughput</a>
    <a id="system-link" href="system.html">System</a>
    <a id="network-link" href="network.html">Network</a>
    <a id="migrations-link" href="migrations.html">Migrations</a>
    <a id="filetrackers-link" href="filetrackers.html">Transfers</a>
</div>

<div style="margin-left:30px;margin-top:10px;margin-bottom:10px;margin-right:30px">
    <div id='chart-container'>
      <p>	    
        <canvas id="FileTransferChart" height="400px"></canvas>
      </p>	
    </div>
    <div id='chart-slider-container' class='chart-slider-container-grid' >
      <div style="text-align:right">
          <span id='range-start'></span>
      </div>
      <div>
          <input type="range" min=0 max="100" value="0" class="slider" id="myRange">
      </div>
      <div>
          <span id='range-end'></span>
      </div>
    </div>	    
    <div>
       <table id="transfer-table"></table>
    </div>
</div>

<script>
// Datasets
var dates;
var mibPerS;
var transferRate;
var filePath;
var pageIndex;
var startIndex = 0;
var zoomScale = 300;
var baseQuery;

//Charts
var fileTransferChart;

async function getDiagnostic(index, path) {
  try {
    let json = await loadDiagnostic(index);
    let {fileTracker, diagnosticTimeStamp}  = processDiagnostic(json, path);
    let migrationName = getMigrationName(fileTracker, json.diagnosticSet.diagnostics);	  
    processTransferTable(fileTracker, diagnosticTimeStamp, migrationName);	  
    processDiagnosticForFileTransfer(fileTracker, diagnosticTimeStamp);	  
    return;
  } catch (error) {
    console.log(error);
  }
}


function getMigrationName(fileTracker, diagnostics) {
  let migrationId = fileTracker.MigrationId;
  let migrationName;	
  for (let i in diagnostics) {
    if (diagnostics[i].type === 'ActionStoreDiagnosticDTO') {
       if (diagnostics[i].id === migrationId) {
         migrationName = diagnostics[i].migrationId;
         break;
       }
    }	    
  }
  return migrationName;	
}


function processTransferTable(fileTracker, diagnosticTimeStamp, migrationName) {
  let percentageDone = Math.floor((fileTracker.BytesTransferred * 100)/fileTracker.FileLength);
  let endTime;
  if (fileTracker.IsComplete) {
     endTime = fileTracker.CompleteTime
  } else {
     endTime = diagnosticTimeStamp > fileTracker.lastUpdate ? diagnosticTimeStamp : fileTracker.LastUpdate;	  
  }
  let transferTime = endTime - fileTracker.StartTime;	
  let lastUpdate = fileTracker.LastUpdate;
  let transferType = fileTracker.StatsType;	
  let migrationId = fileTracker.MigrationId;	

  let text = "<table>";
  text += "<tr><td>Path</td><td>" + fileTracker.Path + "</td></tr>";	
  text += "<tr onclick=\"location.href=\'" + localGetMigrationLink(migrationName) + "\';\"  style=\"cursor: pointer;\">";
  text += "<td>Migration</td><td>" + migrationName + " (" + migrationId + ")</td></tr>";
  text += "<tr><td title=\"File will be transferred either due to the initial migration root scan or due to client activity after the initial scan.\">Activity Type</td>";
  text += "<td>" + transferType + "</td></tr>"; 	
  let sourceEventCreationTimeStamp = fileTracker.SourceEventCreationTimeStamp ? true : false;
  if (sourceEventCreationTimeStamp) {
     text += "<tr><td title=\"Filesystem Event or Scan Queued Time.\">Source Event Creation Time</td><td align =\"left\">" + new Date(fileTracker.SourceEventCreationTimeStamp).toISOString() + "</td></tr>";	
  }
  let ldmEventCreationTimeStamp = fileTracker.LdmEventCreationTimeStamp ? true : false;
  if (ldmEventCreationTimeStamp) {
     let tableEntry;
     if (sourceEventCreationTimeStamp) {
       let delta = fileTracker.LdmEventCreationTimeStamp - fileTracker.SourceEventCreationTimeStamp;
       tableEntry = new Date(fileTracker.LdmEventCreationTimeStamp).toISOString() + "  (" + msToTime(delta)  + ")";
     } else {
       tableEntry = new Date(fileTracker.LdmEventCreationTimeStamp).toISOString()
     }
     text += "<tr><td title=\"LiveData Migrator Action Queued Time.\">Action Queued Time</td><td align=\"left\">" + tableEntry + "</td></tr>";	
     text += "<tr><td>Start Time</td><td align=\"left\">" + new Date(fileTracker.StartTime).toISOString() + "  (" + msToTime(fileTracker.StartTime - fileTracker.LdmEventCreationTimeStamp) + ")</td></tr>";
  } else {
     text += "<tr><td>Start Time</td><td align=\"left\">" + new Date(fileTracker.StartTime).toISOString() + "</td></tr>";
  }
  text += "<tr><td>Time of Last Write</td><td align=\"left\">" + new Date(lastUpdate).toISOString() + "  (" +  msToTime(lastUpdate - fileTracker.StartTime)   +")</td></tr>";	
  let captureTime = diagnosticTimeStamp;
  if (captureTime < lastUpdate) {
     captureTime = lastUpdate;
  }
  text += "<tr><td>Capture Time</td><td align=\"left\">" + new Date(captureTime).toISOString() + "  (" + msToTime(captureTime - lastUpdate)  +")</td></tr>";
  if (fileTracker.IsComplete) {
    text += "<tr><td>Completed Time</td><td align=\"left\">" 
     + new Date(fileTracker.CompleteTime).toISOString() + " (" + msToTime(transferTime) + ")</td></tr>";
  } else {
    text += "<tr><td>Completed Time</td><td>-</td></tr>";
  }	
  text += "<tr><td>Time Transferring</td><td>" + msToTime(transferTime)  + "</td></tr>"	
  let latencyAvailable = fileTracker.EventLatency ? true : false;
  if (latencyAvailable) {
     text += "<tr><td>Migration Latency</td><td>" + secondsToTime(fileTracker.EventLatency) + "</td></tr>";	
  }
  text += "<tr><td>Transferred Bytes / File Size</td><td>" + humanFileSize(fileTracker.BytesTransferred, true) + 
           " / " + humanFileSize(fileTracker.FileLength, true) + " ("  + percentageDone  + "%)</td></tr>";	
  text += "<tr><td>Average Transfer Rate</td><td>" + Math.floor(toMBSecond(fileTracker.BytesPerSecond)) + " Mbit/s</td></tr>";	
  text += "<tr><td title=\"There may be more than one attempt to transfer the file if there was a previous failure transferring it.\">Transfer Attempts</td><td>" + fileTracker.AttemptCount + "</td></tr>";	
  text += "</table>";	
  document.getElementById("transfer-table").innerHTML = text;
}


function processDiagnostic(json, path){
  let diagnostic;	
  let diagnosticTimeStamp;	
  for (let j in json.diagnosticSet.diagnostics) {
    diagnostic = json.diagnosticSet.diagnostics[j];
    if (diagnostic.type === 'FileTrackerDiagnosticDTO') {	    
      diagnosticTimeStamp = diagnostic.timeStamp;	    
      break;
    }
  }
  
  let fileTracker;
  for (let i in diagnostic.fileTrackers) {
      fileTracker = diagnostic.fileTrackers[i];
      if ( fileTracker.Path === path) {
        break;
      }
  }
  return {fileTracker, diagnosticTimeStamp};
}

function processDiagnosticForFileTransfer(fileTracker, diagnosticTimeStamp) {
  if (fileTracker.IsComplete) {
    // Complete transfers cannot be plotted
    document.getElementById("chart-slider-container").style.display = "none";	  
    document.getElementById("chart-container").style.display = "none";	  
    return;	  
  }	  
  let seconds = [];
  let bytesForSecond = [];
  let endTime;
  if (fileTracker.Buckets.length === 0) {
    endTime = diagnosticTimeStamp;
    for (let i = fileTracker.StartTime; i < endTime; i = i + 1000) {
       seconds.push(i);
       bytesForSecond.push(0);
    }
    seconds.push(endTime);
    bytesForSecond.push(fileTracker.BytesTransferred);
    plotFileTransferGraph(fileTracker, seconds, bytesForSecond);
    return;
  }

  let buckets = fileTracker.Buckets;
  let startTime = Math.floor(fileTracker.StartTime / 1000);
  let lastUpdate = Math.floor(fileTracker.LastUpdate / 1000);
  let diagnosticTimeSeconds = Math.floor(diagnosticTimeStamp/ 1000);
  endTime = lastUpdate > diagnosticTimeSeconds ? lastUpdate : diagnosticTimeSeconds;
  let j = 0;
  for (i = startTime; i <= endTime; i++) {
    if (j < buckets.length &&  buckets[j].Second  == i) { 
      bytesForSecond.push(buckets[j].BytesForSecond);
      j++;
    } else {
      bytesForSecond.push(0);
    }
    seconds.push(i * 1000);
  }
  
  plotFileTransferGraph(fileTracker, seconds, bytesForSecond);
  return;
}


var slider = document.getElementById("myRange");
slider.oninput = function() {
  startIndex = parseInt(this.value);
  pageIndex = startIndex
  reWriteLinks(pageIndex, zoomScale);
  redrawChart();
}

function redrawChart() {
  let endIndex = startIndex + zoomScale;
  if (endIndex > dates.length) {
    endIndex = dates.length;
  }
  document.getElementById("range-start").innerHTML = dates[startIndex];
  document.getElementById("range-end").innerHTML = dates[endIndex-1]; 
  fileTransferChart.data.labels = dates.slice(startIndex, endIndex);
  fileTransferChart.data.datasets[0].data = transferRate.slice(startIndex, endIndex);  
  fileTransferChart.data.datasets[1].data = mibPerS.slice(startIndex, endIndex);  
  fileTransferChart.update();
}


function plotFileTransferGraph(fileTracker, seconds, bytesForSecond) {
  dates = seconds.map(toDate);
  mibPerS = bytesForSecond.map(toMBSecond);
  transferRate = bytesForSecond;	
  let percentageDone = Math.floor((fileTracker.BytesTransferred * 100)/fileTracker.FileLength);

  if (dates.length <= 360) {
    endIndex = dates.length;	  
    // No Slider
    document.getElementById("chart-slider-container").style.display = "none";	  
  } else {
    endIndex = startIndex + zoomScale; 
    // Need to setup Slider Range 
    document.getElementById("myRange").max = dates.length;
    document.getElementById("range-start").innerHTML = dates[0];
    document.getElementById("range-end").innerHTML = dates[endIndex-1]; 
  }	  


  fileTransferChart = new Chart("FileTransferChart", {
   type: "line",
    data: {
      labels: dates.slice(startIndex, endIndex),
      datasets: [{
        label: "Bytes Per Second",
        fill: false,
        lineTension: 0.4,
        backgroundColor: transparentize(255, 165, 0, 0.5),
        borderColor: 'rgb(255,165,0)',
        data: transferRate.slice(startIndex, endIndex),
        yAxisID: 'y'
      },
      {
        label: "Mbit/s",
        fill: false,
        lineTension: 0.4,
        backgroundColor:  transparentize(54, 162, 235, 0.5),
        borderColor: 'rgb(54, 162, 235)',
        data: mibPerS.slice(startIndex, endIndex),
        yAxisID: 'y1',
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        title: {
          display: true,
          text: [[fileTracker.Path], '  (' + percentageDone + '% transferred, size: ' + humanFileSize(fileTracker.FileLength, true) +')'],
        }
      },
      scales: {
        x: {
          display: true,
          title: {
            display: false,
            text: 'Date'
          },
          ticks: {
             autoSkip: true,
             maxTicksLimit: 20
          }
        },
        y: {
          display: true,
          type: 'linear',
          min: 0,
          title: {
            display: true,
            text: 'Bytes Per Second'
          }
        },
        y1: {
          display: true,
          type: 'linear',
          min: 0.0,
          position: 'right', 
          grid: {
             drawOnChartArea: false, // only want the grid lines for one axis to show up
          },
          title: {
            display: true,
            text: 'Mbit/s'
          }
        }
       }
     }
  });
}

function localReWriteLinks() {
  let [startTimestamp, middleTimestamp, endTimestamp] = getPageDateRange();
  baseQuery = "?start=" + startTimestamp + "&middle=" + middleTimestamp + "&end=" + endTimestamp;
  document.getElementById('index-link').href = "index.html" + baseQuery;
  document.getElementById('throughput-link').href = "throughput.html" + baseQuery;
  document.getElementById('system-link').href = "system.html" + baseQuery;
  document.getElementById('filetrackers-link').href = "filetrackers.html" + baseQuery;
  document.getElementById('migrations-link').href = "migrations.html" + baseQuery;
  document.getElementById('network-link').href = "network.html" + baseQuery;
  return middleTimestamp;
}

function localGetMigrationLink(migrationName) {
  return "migration.html" + baseQuery + "&migration=" + encodeURIComponent(migrationName);
}


const urlParams = new URLSearchParams(window.location.search);
filePath = urlParams.get('path');
pageIndex = localReWriteLinks();
getDiagnostic(pageIndex, filePath);

</script>
</body>
</html>
